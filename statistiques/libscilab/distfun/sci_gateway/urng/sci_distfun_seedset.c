
/*
* Copyright (C)  2012 - Michael Baudin
* Copyright (C)  2001 - Bruno Pincon
* Copyright (C) ENPC
*
* This file must be used under the terms of the CeCILL.
* This source file is licensed as described in the file COPYING, which
* you should have received as part of this distribution.  The terms
* are also available at
* http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
*
*/

#include <string.h>
#include <math.h>

// From Distfun
#include "gwsupport.h"
#include "gw_distfunurng.h"
#include "unifrng.h"

// From Scilab:
#include "Scierror.h"
#include "sciprint.h"
#include "localization.h"
#include "stack-c.h"

/**************************************************
distfun_seedset(S)
distfun_seedset(s1,s2,s3,s4) 

Sets the state of the current base generator

for mt: distfun_seedset(S)
S is a vector of integers of dim 1 or 625 
The first component is an index and must be in [1,624], 
the 624 last ones must be in [0,2^32[) (but must not be all zeros) ; 
a simpler initialisation may be done with only one integer s1 (s1 must be in [0,2^32[)

for kiss: distfun_seedset(s1,s2,s3,s4) 
4 integers s1,s2, s3,s4 in [0,2^32[ must be provided ;

for clcg2: distfun_seedset(s1,s2)
2 integers s1 in [1,2147483562] and s2 in [1,2147483398] must be given ;

for clcg4: distfun_seedset(s1,s2,s3,s4) 
4 integers s1 in [1,2147483646], 
s2 in [1,2147483542], s3 in [1,2147483422], 
s4 in [1,2147483322] are required ; 
CAUTION : with clcg4 you set the seeds of the current virtual generator 
but you may lost the synchronisation between this one and the others 
virtuals generators.
In other words, the sequence generated is not warranty to be 
non over-lapping with a sequence generated by another virtual generator. 
Users should consider the distfun_urngsetall function instead.

for urand: distfun_seedset(S)
1 integer S in [0,2^31[ must be given.

for fsultra: distfun_seedset(S) or distfun_seedset(s1,s2) 
S is a vector of integers of dim 40 (the first component is an index 
and must be in [0,37], the 2d component is a flag (0 or 1), 
the 3d an integer in [1,2^32[ and the 37 others integers in [0,2^32[).
A simpler (and recommended) initialisation may be done with 
two integers s1 and s2 in [0,2^32[.

for crand: distfun_seedset(S)
1 integer S in [1,2^15[ must be given.

***********************************************************************/

int seedset_getFourDoubles(char * fname , double * s1, double *s2, double *s3, double *s4)
{
	int readFlag;

	readFlag = gwsupport_GetScalarDouble( fname, 1, s1 );
	if ( readFlag == GWSUPPORT_ERROR)
	{ 
		return GWSUPPORT_ERROR;
	}
	readFlag = gwsupport_GetScalarDouble( fname, 2, s2 );
	if ( readFlag == GWSUPPORT_ERROR)
	{ 
		return GWSUPPORT_ERROR;
	}
	readFlag = gwsupport_GetScalarDouble( fname, 3, s3 );
	if ( readFlag == GWSUPPORT_ERROR)
	{ 
		return GWSUPPORT_ERROR;
	}
	readFlag = gwsupport_GetScalarDouble( fname, 4, s4 );
	if ( readFlag == GWSUPPORT_ERROR)
	{ 
		return GWSUPPORT_ERROR;
	}
	return GWSUPPORT_OK;
}
int seedset_getTwoDoubles(char * fname , double * s1, double * s2)
{
	int readFlag;
	readFlag = gwsupport_GetScalarDouble( fname, 1, s1 );
	if ( readFlag == GWSUPPORT_ERROR)
	{ 
		return GWSUPPORT_ERROR;
	}
	readFlag = gwsupport_GetScalarDouble( fname, 2, s2 );
	if ( readFlag == GWSUPPORT_ERROR)
	{ 
		return GWSUPPORT_ERROR;
	}
	return GWSUPPORT_OK;
}

int sci_distfun_seedset(char *fname,unsigned long fname_len)
{
	int current_gen;
	int ms1, ns1;
	int readFlag;
	double * ps1 = NULL;
	double s1, s2, s3, s4;

	Nbvars = 0;
	CheckRhs(1,4);
	CheckLhs(0,1);

	unifrng_getcurrentgen(&current_gen);
	switch(current_gen)
	{
	case(MT) :
		CheckRhs(1,1);
		readFlag = gwsupport_GetRealMatrixOfDoubles( fname, 1, &ps1, &ms1, &ns1);
		if ( readFlag == GWSUPPORT_ERROR)
		{ 
			return 0;
		}
		if ( ms1*ns1 == 1)          /* simple init of mt     */
		{ 
			readFlag = unifrng_mt_set_state_simple(ps1[0]);
			if (readFlag==UNIFRNG_ERROR) 
			{
				Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"mt");
				return(0);
			} 
		}
		else if ( ms1*ns1 == 625 )  /* init of all the state */
		{ 
			readFlag = unifrng_mt_set_state(ps1);
			if (readFlag==UNIFRNG_ERROR) 
			{
				Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"mt");
				return(0);
			}
		}
		else
		{
			Scierror(999,_("%s: Wrong values for input argument: Vector of %d or %d values for %s expected.\n"),fname,1, 625,"mt");
			return 0;
		}
		break;

	case(FSULTRA) :
		CheckRhs(1,2);
		if ( Rhs == 1 ) /* init via a "complete" state */
		{
			readFlag = gwsupport_GetRealMatrixOfDoubles( fname, 1, &ps1, &ms1, &ns1);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = gwsupport_CheckSize ( fname, 1, 40, 1, ms1, ns1);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = unifrng_fsultra_set_state(ps1);
			if (readFlag==UNIFRNG_ERROR) 
			{
				Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"fsultra");
				return(0);
			}
		}
		else if ( Rhs == 2 ) /* init with 2 integers (like before) */
		{
			readFlag = seedset_getTwoDoubles(fname, &s1, &s2);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = unifrng_fsultra_set_state_simple(s1,s2);
			if (readFlag==UNIFRNG_ERROR) 
			{
				Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"fsultra");
				return(0);
			}
		}
		else
		{
			Scierror(999,_("%s: Wrong number of input arguments: %d or %d expected for '%s' option with the %s generator.\n"),fname,2,3,"setsd","fsultra");
			return 0;
		}
		break;

	case(KISS) :
		CheckRhs(1,4);
		if (Rhs==1)
		{
			readFlag = gwsupport_GetRealMatrixOfDoubles( fname, 1, &ps1, &ms1, &ns1);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = gwsupport_CheckSize ( fname, 1, 4, 1, ms1, ns1);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = unifrng_kiss_set_state(ps1[0],ps1[1],ps1[2],ps1[3]);
			if (readFlag==UNIFRNG_ERROR) 
			{
				Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"kiss");
				return 0;
			}
		}
		else
		{
			CheckRhs(4,4);
			readFlag = seedset_getFourDoubles(fname, &s1, &s2, &s3, &s4);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = unifrng_kiss_set_state(s1,s2,s3,s4);
			if (readFlag==UNIFRNG_ERROR) 
			{
				Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"kiss");
				return 0;
			}
		}
		break;

	case(CLCG4) :
		CheckRhs(1,4);
		if (Rhs==1)
		{
			readFlag = gwsupport_GetRealMatrixOfDoubles( fname, 1, &ps1, &ms1, &ns1);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = gwsupport_CheckSize ( fname, 1, 4, 1, ms1, ns1);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = unifrng_clcg4_set_initial_seed(ps1[0],ps1[1],ps1[2],ps1[3]);
			if (readFlag==UNIFRNG_ERROR) 
			{
				Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"clcg4");
				return 0;
			}
		} 
		else
		{
			CheckRhs(4,4);
			readFlag = seedset_getFourDoubles(fname, &s1, &s2, &s3, &s4);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = unifrng_clcg4_set_initial_seed(s1,s2,s3,s4);
			if (readFlag==UNIFRNG_ERROR) 
			{
				Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"clcg4");
				return 0;
			}
		}
		break;

	case(CLCG2) :
		CheckRhs(1,2);
		if ( Rhs == 1 ) /* init via a "complete" state */
		{
			readFlag = gwsupport_GetRealMatrixOfDoubles( fname, 1, &ps1, &ms1, &ns1);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = gwsupport_CheckSize ( fname, 1, 2, 1, ms1, ns1);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = unifrng_clcg2_set_state(ps1[0],ps1[1]);
			if (readFlag==UNIFRNG_ERROR) 
			{ 
				Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"clcg2");
				return 0;
			}
		}
		else
		{
			readFlag = seedset_getTwoDoubles(fname, &s1, &s2);
			if ( readFlag == GWSUPPORT_ERROR)
			{ 
				return 0;
			}
			readFlag = unifrng_clcg2_set_state(s1,s2);
			if (readFlag==UNIFRNG_ERROR) 
			{ 
				Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"clcg2");
				return 0;
			}
		}
		break;

	case(URAND) :
		CheckRhs(1,1);
		readFlag = gwsupport_GetScalarDouble( fname, 1, &s1 );
		if ( readFlag == GWSUPPORT_ERROR)
		{ 
			return 0;
		}
		readFlag = unifrng_urand_set_state(s1);
		if (readFlag==UNIFRNG_ERROR) 
		{
			Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"urand");
			return 0;
		}
		break;

	case(CRAND) :
		CheckRhs(1,1);
		readFlag = gwsupport_GetScalarDouble( fname, 1, &s1 );
		if ( readFlag == GWSUPPORT_ERROR)
		{ 
			return 0;
		}
		readFlag = unifrng_crand_set_state(s1);
		if (readFlag==UNIFRNG_ERROR) 
		{
			Scierror(999,_("%s: Internal error: Cannot set state of %s generator.\n"),fname,"crand");
			return 0;
		}
		break;
	}
	LhsVar(1) = 0;

	return 0;
}
